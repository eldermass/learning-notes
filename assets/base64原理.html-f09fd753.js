import{_ as t,Y as s,Z as a,a0 as n}from"./framework-6d304b95.js";const e={},d=n(`<h1 id="base64-编码原理" tabindex="-1"><a class="header-anchor" href="#base64-编码原理" aria-hidden="true">#</a> Base64 编码原理</h1><h2 id="base64-的由来" tabindex="-1"><a class="header-anchor" href="#base64-的由来" aria-hidden="true">#</a> Base64 的由来</h2><p>目前 Base64 已经成为网络上常见的传输 8Bit 字节代码的编码方式之一。在做支付系统时，系统之间的报文交互都需要使用 Base64 对明文进行转码，然后再进行签名或加密，之后再进行（或再次 Base64）传输。那么，Base64 到底起到什么作用呢？</p><p>在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64 的出现就是为了解决此问题，它是基于 64 个可打印的字符来表示二进制的数据的一种方法。</p><p>电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此 Base64 就登场了。随之，Base64 在 URL、Cookie、网页传输少量二进制文件中也有相应的使用。</p><h2 id="base64-的编码原理" tabindex="-1"><a class="header-anchor" href="#base64-的编码原理" aria-hidden="true">#</a> Base64 的编码原理</h2><p>Base64 的原理比较简单，每当我们使用 Base64 时都会先定义一个类似这样的数组：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面就是 Base64 的索引表，字符选用了&quot;A-Z、a-z、0-9、+、/&quot; 64 个可打印字符，这是标准的 Base64 协议规定。在日常使用中我们还会看到“=”或“==”号出现在 Base64 的编码结果中，“=”在此是作为填充字符出现，后面会讲到。</p><p>具体转换步骤</p><ul><li><p>第一步，将待转换的字符串每三个字节分为一组，每个字节占 8bit，那么共有 24 个二进制位。</p></li><li><p>第二步，将上面的 24 个二进制位每 6 个一组，共分为 4 组。</p></li><li><p>第三步，在每组前面添加两个 0，每组由 6 个变为 8 个二进制位，总共 32 个二进制位，即四个字节。</p></li><li><p>第四步，根据 Base64 编码对照表（见下图）获得对应的值。</p></li></ul><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0 　 A</td><td>17 　 R</td><td>34 　 i</td><td>51 z</td></tr><tr><td>1 　 B</td><td>18 　 S</td><td>35 　 j</td><td>52 　 0</td></tr><tr><td>2 　 C</td><td>19 　 T</td><td>36 　 k</td><td>53 　 1</td></tr><tr><td>3 　 D</td><td>20 　 U</td><td>37 　 l</td><td>54 　 2</td></tr><tr><td>4 　 E</td><td>21 　 V</td><td>38 　 m</td><td>55 　 3</td></tr><tr><td>5 　 F</td><td>22 　 W</td><td>39 　 n</td><td>56 　 4</td></tr><tr><td>6 　 G</td><td>23 　 X</td><td>40 　 o</td><td>57 　 5</td></tr><tr><td>7 　 H</td><td>24 　 Y</td><td>41 　 p</td><td>58 　 6</td></tr><tr><td>8 　 I</td><td>25 　 Z</td><td>42 　 q</td><td>59 　 7</td></tr><tr><td>9 　 J</td><td>26 　 a</td><td>43 　 r</td><td>60 　 8</td></tr><tr><td>10 　 K</td><td>27 　 b</td><td>44 　 s</td><td>61 　 9</td></tr><tr><td>11 　 L</td><td>28 　 c</td><td>45 　 t</td><td>62 　+</td></tr><tr><td>12 　 M</td><td>29 　 d</td><td>46 　 u</td><td>63 　/</td></tr><tr><td>13 　 N</td><td>30 　 e</td><td>47 　 v</td><td></td></tr><tr><td>14 　 O</td><td>31 　 f</td><td>48 　 w</td><td></td></tr><tr><td>15 　 P</td><td>32 　 g</td><td>49 　 x</td><td></td></tr><tr><td>16 　 Q</td><td>33 　 h</td><td>50 　 y</td><td></td></tr></tbody></table><p>从上面的步骤我们发现：</p><ul><li>Base64 字符表中的字符原本用 6 个 bit 就可以表示，现在前面添加 2 个 0，变为 8 个 bit，会造成一定的浪费。因此，- Base64 编码之后的文本，要比原文大约三分之一。</li><li>为什么使用 3 个字节一组呢？因为 6 和 8 的最小公倍数为 24，三个字节正好 24 个二进制位，每 6 个 bit 位一组，恰好能够分为 4 组。</li></ul><h2 id="示例说明" tabindex="-1"><a class="header-anchor" href="#示例说明" aria-hidden="true">#</a> 示例说明</h2><p>以下图的表格为示例，我们具体分析一下整个过程。</p><p><img src="https://img-blog.csdnimg.cn/20190517212249969.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oZWxsby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="示例"></p><ul><li><p>第一步：“M”、“a”、&quot;n&quot;对应的 ASCII 码值分别为 77，97，110，对应的二进制值是 01001101、01100001、01101110。如图第二三行所示，由此组成一个 24 位的二进制字符串。</p></li><li><p>第二步：如图红色框，将 24 位每 6 位二进制位一组分成四组。</p></li><li><p>第三步：在上面每一组前面补两个 0，扩展成 32 个二进制位，此时变为四个字节：00010011、00010110、00000101、00101110。分别对应的值（Base64 编码索引）为：19、22、5、46。</p></li><li><p>第四步：用上面的值在 Base64 编码表中进行查找，分别对应：T、W、F、u。因此“Man”Base64 编码之后就变为：TWFu。</p></li></ul><h3 id="位数不足情况" tabindex="-1"><a class="header-anchor" href="#位数不足情况" aria-hidden="true">#</a> 位数不足情况</h3><p>上面是按照三个字节来举例说明的，如果字节数不足三个，那么该如何处理？</p><img src="https://img-blog.csdnimg.cn/20190517212307382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oZWxsby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="示例"><ul><li>两个字节：两个字节共 16 个二进制位，依旧按照规则进行分组。此时总共 16 个二进制位，每 6 个一组，则第三组缺少 2 位，用 0 补齐，得到三个 Base64 编码，第四组完全没有数据则用“=”补上。因此，上图中“BC”转换之后为“QKM=”；</li><li>一个字节：一个字节共 8 个二进制位，依旧按照规则进行分组。此时共 8 个二进制位，每 6 个一组，则第二组缺少 4 位，用 0 补齐，得到两个 Base64 编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“A”转换之后为“QQ==”；</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h3><ul><li>大多数编码都是由字符串转化成二进制的过程，而 Base64 的编码则是从二进制转换为字符串。与常规恰恰相反，</li><li>Base64 编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱 Base64 编码来进行加密。</li><li>中文有多种编码（比如：utf-8、gb2312、gbk 等），不同编码对应 Base64 编码结果都不一样。</li></ul><h3 id="延伸" tabindex="-1"><a class="header-anchor" href="#延伸" aria-hidden="true">#</a> 延伸</h3><p>上面我们已经看到了 Base64 就是用 6 位（2 的 6 次幂就是 64）表示字符，因此成为 Base64。同理，Base32 就是用 5 位，Base16 就是用 4 位。大家可以按照上面的步骤进行演化一下。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 1. 三个字节一队，3 * 8 = 24 bit</span>
<span class="token comment"># 2. 每6个bit一组，分为4组。24 / 6 = 4组，  每组2**6=64种可能就是所谓的base64</span>
<span class="token comment"># 3. 每组前补两个0，组成一个字节，</span>
<span class="token comment"># 4. 根据base64编码，把相应二进制转为字符， 不足用==补足</span>
<span class="token comment"># 5. 结果资源变大1/3，约为原来的4/3</span>

例如：
文本            a
asiic           <span class="token number">97</span>
二进制          <span class="token number">011000</span>  <span class="token number">01</span><span class="token punctuation">(</span>补<span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">.</span>       <span class="token punctuation">.</span>
base64索引      <span class="token number">24</span>      <span class="token number">16</span>          <span class="token punctuation">.</span>       <span class="token punctuation">.</span>
base64          Y       Q           <span class="token operator">=</span>       <span class="token operator">=</span>

<span class="token comment"># python</span>
<span class="token keyword">import</span> base64
base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 结果为 YQ==</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),p=[d];function i(o,l){return s(),a("div",null,p)}const r=t(e,[["render",i],["__file","base64原理.html.vue"]]);export{r as default};
